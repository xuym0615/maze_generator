# maze_generator
使用 Python 3.x 编写，主要利用 Tkinter 库进行图形界面开发。
开发过程中我主要使用了 Visual Studio Code进行代码编辑和调试。
本项目可在 Windows 、Linux等操作系统上运行，要求安装 Python 3.x 环境及标准库。

1. 程序总体介绍
本项目用 Python 写成，主要实现了一个图形界面的迷宫“生成”和“寻路”程序。程序中有两大部分：
迷宫生成：用几种不同的算法来构造一个迷宫，也就是一个由很多小方格组成的区域，每个小方格周围都有墙，程序会通过“去掉”部分墙壁让不同方格相连，最终形成一个“完美迷宫”（没有孤立区域，每个格子都连通）。
迷宫寻路：在生成好的迷宫中，程序再用不同的算法寻找从起点到终点的路径，同时用动画动态地展示搜索的过程。
此外，程序使用 Python 自带的 tkinter 模块来创建图形界面，让用户可以选择不同的算法、点击按钮后看到迷宫的生成和寻路的动画。

2. 全局参数和算法说明
在代码开头，有一些全局变量和说明信息，主要用来设置迷宫的基本参数和显示文字说明：
全局参数：
CELL_SIZE = 10：表示每个小格子的边长为10个像素。
MAZE_ROWS = 50 和 MAZE_COLS = 50：迷宫一共50行50列，也就是说总共有2500个格子。
DELAY = 5：每次动画更新时延时5毫秒。
STEPS_PER_UPDATE = 100：每次动画更新时，程序会处理100步（用来控制动画的速度）。
算法说明：
用两个字典 gen_descriptions 和 path_descriptions 存放了生成迷宫和寻路算法的简单介绍文字（比如“深度优先搜索”、“随机化 Kruskal 算法”等）。这些说明会显示在界面下方的文本框中，告诉用户当前选择的算法大致是怎么工作的。

3. 数据结构
3.1 Cell 类（表示迷宫中的一个小格子）
属性：
row 和 col：记录该格子在迷宫中的行号和列号。
walls：一个字典，记录这个格子四个方向（上、右、下、左）是否有墙，初始时四面都有墙（都为 True）。
visited：一个标记，用于在生成迷宫的过程中判断这个格子是否已经访问过。
方法：
draw(canvas)：这个方法负责在 tkinter 的画布上画出当前格子的四条墙。如果某一面墙存在，就画一条线；如果已经被删除了（False），就不画那条线。
3.2 Maze 类（表示整个迷宫）
属性：
rows 和 cols：记录迷宫的行数和列数。
grid：一个二维列表，每个元素都是一个 Cell 对象。这样就把整个迷宫看作一个由许多小格子组成的大网格。
方法：
draw(canvas)：遍历迷宫中所有的格子，让每个格子都调用自己的 draw 方法在画布上绘制出来。
get_neighbors(cell)：给定一个格子，返回它上下左右的相邻格子（注意边界情况）。
get_accessible_neighbors(cell)：返回那些和当前格子之间“无墙相隔”的邻居格子，也就是说可以直接通过而不受墙壁阻挡的格子。
remove_walls(current, next_cell)：用来删除两个相邻格子之间的墙壁，使它们连通。程序通过比较两个格子在行或列上的差别，判断该删除哪一面墙。
add_wall(cell1, cell2)：与 remove_walls 正好相反，用来在两个格子之间加上墙。
clear_interior_walls()：把迷宫内部所有的墙（除边界墙外）都去掉。这主要是给“递归分割算法”做准备，因为这个算法先把所有内部墙都去掉，再逐步添加分隔墙。

4. 迷宫生成算法
程序中实现了四种不同的迷宫生成方法，每种算法都有自己的特点和生成过程，并且都是“动态”展示的，也就是说你能看到迷宫一步步生成的动画效果。
4.1 DFS（深度优先搜索）生成迷宫
思路：
从起点开始，随机选择一个未访问的相邻格子，删除它们之间的墙，然后把这个新格子作为当前点继续探索。如果当前格子没有未访问的邻居，就退回到上一个格子（回溯）。
实现：
使用一个“栈”来记录探索路径，每一步都从栈顶取出当前格子，然后随机选择一个未访问的邻居，删除墙壁，再把邻居加入栈中。通过反复执行这一过程，直到所有格子都被访问过。
4.2 Kruskal 算法生成迷宫
思路：
将迷宫中所有可能连接相邻两个格子的“边”放到一个列表中，然后随机打乱这些边的顺序。接着用一种叫“并查集”的工具，检查每条边连接的两个格子是否已经在同一个区域内；如果不在，则删除这条边对应的墙，使两个区域合并。这样最后就会生成一个没有循环的迷宫。
实现：
定义了一个 UnionFind 类来实现并查集。
将所有可能的边（水平和垂直方向的相邻格子）加入列表，并随机打乱顺序。
按顺序处理每条边，只有在两个格子属于不同的集合时才删除墙，并合并集合。
4.3 Prim 算法生成迷宫
思路：
从起点开始，把与起点相邻的边加入候选列表，然后随机选择一条候选边，如果这条边连接的另一个格子还没有加入迷宫，就删除这条边对应的墙，将该格子加入迷宫，再把它的相邻边加入候选列表。不断重复直到迷宫全部生成。
实现：
用一个二维列表 linked 记录哪些格子已经加入迷宫，从起点开始逐步扩展候选边，随机选择边来连接新的格子。
4.4 递归分割算法生成迷宫
思路：
先把迷宫内部的所有墙去掉，然后按照一定的规则递归地在迷宫中添加分隔墙。分隔时，程序会随机选择在某一行或某一列上添加墙，并在墙上留一个空口作为通道。递归地对分隔出来的区域再重复这一过程，最终形成一个迷宫。
实现：
首先调用 clear_interior_walls() 把内部墙去掉。
使用递归函数 recursive_division 来记录每一步要添加的墙的位置，存储在一个 actions 列表中。
最后按照记录的顺序逐步添加墙，并显示生成动画。

5. 辅助绘制函数
为了让迷宫生成和寻路过程看起来更直观，程序还包含了一些用来绘图的辅助函数：
draw_cell_explored(canvas, row, col, color)：在指定的格子上画一个填充色，用来标记这个格子被探索过。比如在寻路时，可以用“浅蓝色”标记已经搜索过的区域。
draw_direct_blue_path(canvas, maze, path)：将最终找到的路径用蓝色的线连起来，显示出从起点到终点的通路。

6. 寻路算法（动态展示寻找出路的过程）
在生成迷宫后，程序还可以用三种不同的算法寻找从起点（迷宫左上角）到终点（迷宫右下角）的路，并用动画显示搜索的过程。
6.1 BFS（广度优先搜索）
思路：
从起点开始，先搜索所有离起点最近的格子，然后逐步向外扩展。它保证能找到最短路径。
实现：
使用一个“队列”来保存待访问的格子，每次从队列中取出一个格子，检查它的所有无墙相连的邻居，如果没有访问过就加入队列，并记录下是从哪个格子过来的。最终当找到终点时，通过回溯记录得到完整的路径，并逐步用动画标记出来。
6.2 DFS（深度优先搜索）
思路：
与生成迷宫时的 DFS 类似，从起点开始不断深入搜索，直到走到死胡同再回退。
实现：
用“栈”来实现，每次从栈中取出一个格子，检查其邻居，如果是新的格子就加入栈。搜索过程中也会用不同颜色标记当前探索的路径，找到终点后展示最终路径。
6.3 A* 算法
思路：
A* 算法结合了当前走过的距离（G 值）和从当前格子到终点的估计距离（H 值，通常用“曼哈顿距离”来计算）。每一步选择总和最小的格子进行扩展，这样通常能更快地找到一条比较优的路径。
实现：
程序中使用字典来记录每个格子的 G 值和 F 值（G + H），并用一个集合保存待扩展的格子。每次从中选出 F 值最小的格子进行处理。和前面两种算法类似，找到终点后回溯出完整路径并动态显示。
注意：这三种寻路算法都有一个 cancel_control 参数，可以用来中断正在进行的动画，防止重复启动寻路。

7. 主界面和用户交互（MazeApp类）
整个程序的图形界面由 MazeApp 类来管理，它主要完成以下几件事：
界面布局：
上半部分分成两块： 
	左边：一个 Canvas（画布），用来显示迷宫和动画效果。
	右边：控制区，里面有一些按钮和单选框（RadioButton），用来选择迷宫生成算法和寻	路算法，还可以点击按钮开始生成迷宫或寻找路径。
下半部分是一个文本框，用来显示当前选中的生成算法和寻路算法的说明文字。
控件功能：
用户可以选择不同的迷宫生成算法（比如 DFS、Kruskal、Prim、递归分割）和寻路算法（BFS、DFS、A*）。
点击“生成迷宫”按钮时，会调用对应的迷宫生成函数，让迷宫一步步生成出来；生成完后还会在起点和终点打开一扇门（去掉部分墙壁）。
点击“寻路”按钮时，会调用对应的寻路算法，动画地展示搜索过程，并最后用红色或蓝色标记出从起点到终点的路径。
动画效果：
迷宫生成和路径搜索的过程都不是一步完成的，而是通过定时延时（canvas.after(DELAY, step)）逐步调用“step”函数来实现动画效果，让用户能看到算法的“探索”过程。

8. 主程序入口
在代码最下方有如下语句：
if __name__ == "__main__":
    root = tk.Tk()
    app = MazeApp(root)
    root.mainloop()
	这几行代码的作用是： 
创建一个 tkinter 的根窗口 root。
用这个窗口创建一个 MazeApp 实例，也就是搭建整个界面和逻辑。
调用 root.mainloop() 进入 tkinter 的事件循环，让界面保持显示并等待用户操作。
